package ngsep.clustering;

import java.util.*;
import java.util.function.BiFunction;

public class FastNJ implements DistanceMatrixClustering {

    // Empty constructor
    public FastNJ () {

    }

    // List helpers

    /**
     *
     * @param xs - A list of elements
     * @param indices - A set of indices of elements to delete
     * @param <A> - Type of the list of elements
     * @return A new list without the elements indexed by the given set
     */
    private <A> List<A> deleteFromList (List<A> xs, Set<Integer> indices) {
        int n = xs.size();
        ArrayList<A> ys = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            if (!indices.contains(i)) ys.add(xs.get(i));
        }
        return ys;
    }

    /**
     *
     * @param xs - A list of elements
     * @param ys - A list of elements
     * @param <A> - Type of both of the given list
     * @return A new list that concatenates the elements on
     * the first list with the elements of the second list
     */
    private <A> List<A> concat (List<A> xs, List<A> ys) {
        List<A> zs = new ArrayList<>();
        zs.addAll(xs);
        zs.addAll(ys);
        return zs;
    }

    /**
     * @param D - Distance Matrix
     * @return A vector from a distance matrix D of size n x n, defined as:
     * rowSumVector_i = 1 / (n - 2) * \sum_{j=1}^n D_{i j} for all 1<= i <= n
     */
    private double[] rowSums (double[][] D) {
        int n = D.length;
        double[] a = new double[n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                a[i] += D[i][j];
            }
            a[i] /= (n - 2.0);
        }
        return a;
    }

    /**
     *
     * @param D - Distance matrix
     * @return An array that contains the minimum of each row of D:
     * rowMinimums(D)_i = \min D_i
     */
    private double[] rowMinimums (double[][] D) {
        int n = D.length;
        double[] min = new double[n];
        Arrays.fill(min, Double.MAX_VALUE);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                min[i] = Math.min(
                        min[i],
                        i != j ? D[i][j] : Double.MAX_VALUE
                );
            }
        }
        return min;
    }

    /**
     *
     * @param D - Distance matrix
     * @param x - A new node that joins a pair of subtrees
     * @param y - A new node that joins a pair of subtrees
     * @return The distance between nodes x and y. Both nodes
     * are new nodes generated by an iteration of FastNJ, defined
     * by the method findNeighbors
     */
    private double distanceBetweenNewNodes (
            double[][] D,
            Pair<Integer, Integer> x,
            Pair<Integer, Integer> y
    ) {
        int u = x.first;
        int v = x.second;
        int p = y.first;
        int q = y.second;
        return 0.5 * (0.5 * (D[u][p] + D[v][p] + D[u][q] + D[v][q]) - D[u][v] - D[p][q]);
    }

    /**
     *
     * @param D - Distance matrix
     * @param rowSumVector - A vector defined as rowSumVector_i = 1 / (n - 2) * \sum_{j=1}^n D_{i j} for all 1<= i <= n
     * @return A matrix S with the estimator of the sum of branch lengths between all leaves (sequences).
     * S_{i j} corresponds to the estimator of the total distance between node i and j within the tree
     */
    private double[][] branchLengthSums (
            double[][] D,
            double[] rowSumVector
    ) {
        int n = D.length;
        double[][] S = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                S[i][j] = D[i][j] - rowSumVector[i] - rowSumVector[j];
                S[j][i] = S[i][j];
            }
        }
        return S;
    }

    /**
     *
     * @param D - Distance matrix
     * @param rowSumVector - A vector defined as rowSumVector_i = 1 / (n - 2) * \sum_{j=1}^n D_{i j} for all 1<= i <= n
     * @return A list of pairs of nodes to be joined. The criterion to select a pair of nodes (u, v) is that:
     * S_{u v} \leq S_{u j} and S_{u v} \leq S_{v j} for all u and v different from j, where S is the matrix
     * with the estimators of the sum of the branch lengths
     */
    private List<Pair<Integer, Integer>> findNeighbors (
            double[][] D,
            double[] rowSumVector
    ) {
        int n = D.length;
        double[][] S = branchLengthSums(D, rowSumVector);
        double[] rowMin = rowMinimums(S);
        boolean[] taken = new boolean[n];
        double eps = 1e-9;
        BiFunction<Double, Double, Boolean> eq = (x, y) -> x - y < eps;
        List<Pair<Integer, Integer>> neighbors = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (!taken[i] && !taken[j] &&
                        eq.apply(S[i][j], rowMin[i]) &&
                        (S[i][j] < rowMin[j] || eq.apply(S[i][j], rowMin[j]))) {
                    neighbors.add(new Pair<>(i, j));
                    taken[i] = true;
                    taken[j] = true;
                }
            }
        }
        return neighbors;
    }

    /**
     *
     * @param D - Distance matrix
     * @param neighbors - A list of pairs with the nodes to be joined
     * @param indexSet - A flattened version of neighbors in the form of a set. Contains the indices of the neighbors in no particular order
     * @return A new distance matrix D' of size n - m where m = |neighbors| = 1/2*|indexSet| and n * n = |D|.
     * All pair of nodes within the neighbors collection are joined with a node, and these new nodes are added at the end
     * of the matrix as rows and columns in the same order as the neighbors list. Afterwards the distances between new and old nodes
     * is calculated, as well as the distance between new nodes using the distanceBetweenNewNodes method
     */
    private double[][] recalculateDistances (
            double[][] D,
            List<Pair<Integer, Integer>> neighbors,
            Set<Integer> indexSet
    ) {
        int n = D.length;
        int m = neighbors.size();
        double[][] newD = new double[n - m][n - m];

        int x = 0;
        int y = 0;
        for (int i = 0; i < n; i++) {
            if (!indexSet.contains(i)) {
                for (int j = 0; j < n; j++) {
                    if (!indexSet.contains(j)) {
                        newD[x][y] = D[i][j];
                        y++;
                    }
                }
                y = 0;
                x++;
            }
        }

        for (int j = n - 2 * m; j < n - m; j++) {
            x = 0;
            for (int i = 0; i < n; i++) {
                if (!indexSet.contains(i)) {
                	Pair<Integer,Integer> ne = neighbors.get(j - (n - 2 * m));
                    newD[x][j] = NJDistances.distanceBetweenNewAndOldNode(D, ne.first , ne.second, i);
                    newD[j][x] = newD[x][j];
                    x++;
                }
            }
        }

        for (int i = n - 2 * m; i < n - m; i++) {
            for (int j = i + 1; j < n - m; j++) {
                newD[i][j] = distanceBetweenNewNodes(
                        D,
                        neighbors.get(i - (n - 2 * m)),
                        neighbors.get(j - (n - 2 * m))
                );
                newD[j][i] = newD[i][j];
            }
        }

        return newD;
    }

    /**
     * Receives a list of nodes (trees) and the distance matrix that specifies the pairwise distance
     * between each node.
     * Runs an iteration of the neighbor joining algorithm, described by the following steps:
     * 1. Calculate a vector rowSumVector_i = 1 / (n - 2) * \sum_{j=1}^n D_{i j} for all 1<= i <= n to use
     * when finding neighbors and calculating their distances.
     * 2. Find a list of neighbors (pairs) to be joined using the criteria specified by the findNeighbors
     * method.
     * 3. Join all the found neighbors generating new subtrees with their respective distances.
     * 4. Recalculate the labels of the trees and the distance matrix taking into account the new
     * generated nodes.
     * @param matrix - Distance matrix
     * @param subtrees - List of node (trees) characterized by the distance matrix
     * @return A pair with the new distance matrix and the new list of trees
     */
    private Pair<DistanceMatrix, List<Dendrogram>> runNeighborJoining (
            DistanceMatrix matrix,
            List<Dendrogram> subtrees
    ) {
        double[][] D = matrix.getDistances();
        int n = D.length;
        List<String> names = matrix.getIds();
        double[] rowSumVector = n == 2 ? new double[]{0, 0} :  rowSums(D);
        List<Pair<Integer, Integer>> neighbors = findNeighbors(D, rowSumVector);

        List<String> newNodeNames = new ArrayList<>();
        for (Pair<Integer, Integer> x : neighbors) {
            int u = x.first;
            int v = x.second;
            newNodeNames.add(names.get(u) + "!" + names.get(v));
        }

        List<Dendrogram> newNodes = new ArrayList<>();
        for (int i = 0; i < neighbors.size(); i++) {
            Pair<Integer, Integer> x = neighbors.get(i);
            int u = x.first;
            int v = x.second;
            String name = newNodeNames.get(i);
            double distance1 = 0.5 * D[u][v];
    		double distance2 = 0.5 * D[u][v];
    		if(n>2) {
    			double [] distances = NJDistances.distanceBetweenNeighbors(D, rowSumVector, u, v);
    			distance1 = distances[0];
    			distance2 = distances[1];
    		}
            newNodes.add(Dendrogram.join2(name, subtrees.get(u), distance1, subtrees.get(v), distance2));
        }

        Set<Integer> indices = new HashSet<>();
        for (Pair<Integer, Integer> x : neighbors) {
            indices.add(x.first);
            indices.add(x.second);
        }

        List<String> newNames = concat(
                deleteFromList(names, indices),
                newNodeNames
        );
        List<Dendrogram> newSubtrees = concat(
                deleteFromList(subtrees, indices),
                newNodes
        );
        double[][] newD = recalculateDistances(D, neighbors, indices);
        return new Pair<>(
                new DistanceMatrix(newNames, newD),
                newSubtrees
        );
    }

    /**
     *
     * @param names - The labels of each leaf in the tree to be constructed
     * @return The initial set of trees, each one containing only one node
     * labeled by the taxa to be clustered
     */
    private List<Dendrogram> initializeSubtrees (List<String> names) {
        List<Dendrogram> subtrees = new ArrayList<>(names.size());
        for (String name : names) subtrees.add(new Dendrogram(name));
        return subtrees;
    }

    /**
     * Clusters a given set of sequences characterized by a pairwise distance
     * matrix. Runs the runNeighborJoining function until the resulting list
     * of trees is reduced to only one tree.
     * @param distances - Initial distance matrix
     * @return - A binary tree (dendrogram) that clusters the given sequences.
     */
    @Override
    public Dendrogram buildDendrogram(DistanceMatrix distances) {
        List<Dendrogram> subtrees = initializeSubtrees(distances.getIds());
        DistanceMatrix matrix = distances;
        while (subtrees.size() > 1) {
            Pair<DistanceMatrix, List<Dendrogram>> njResult = runNeighborJoining(matrix, subtrees);
            matrix = njResult.first;
            subtrees = njResult.second;
        }
        return subtrees.get(0);
    }
}
