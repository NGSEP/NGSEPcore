package ngsep.clustering;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.BiFunction;

public class FastNJ implements DistanceMatrixClustering {

    // Empty constructor
    public FastNJ () {

    }

    // List helpers

    /**
     *
     * @param xs - A list of elements
     * @param indices - A set of indices of elements to delete
     * @param <A> - Type of the list of elements
     * @return A new list without the elements indexed by the given set
     */
    private <A> List<A> deleteFromList (List<A> xs, Set<Integer> indices) {
        int n = xs.size();
        ArrayList<A> ys = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            if (!indices.contains(i)) ys.add(xs.get(i));
        }
        return ys;
    }

    
    /**
     *
     * @param D - Distance matrix
     * @return An array that contains the minimum of each row of D:
     * rowMinimums(D)_i = \min D_i
     */
    private double[] rowMinimums (double[][] D) {
        int n = D.length;
        double[] min = new double[n];
        Arrays.fill(min, Double.MAX_VALUE);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                min[i] = Math.min(min[i], i != j ? D[i][j] : Double.MAX_VALUE);
            }
        }
        return min;
    }

    /**
     *
     * @param D - Distance matrix
     * @param x - A new node that joins a pair of subtrees
     * @param y - A new node that joins a pair of subtrees
     * @return The distance between nodes x and y. Both nodes
     * are new nodes generated by an iteration of FastNJ, defined
     * by the method findNeighbors
     */
    private double distanceBetweenNewNodes (double[][] D, int u, int v, int p, int q) {
        return 0.5 * (0.5 * (D[u][p] + D[v][p] + D[u][q] + D[v][q]) - D[u][v] - D[p][q]);
    }

    /**
     *
     * @param D - Distance matrix
     * @param rowSumVector - A vector defined as rowSumVector_i = 1 / (n - 2) * \sum_{j=1}^n D_{i j} for all 1<= i <= n
     * @return A matrix S with the estimator of the sum of branch lengths between all leaves (sequences).
     * S_{i j} corresponds to the estimator of the total distance between node i and j within the tree
     */
    private double[][] branchLengthSums (double[][] D, double[] rowSumVector) {
        int n = D.length;
        double[][] S = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                S[i][j] = D[i][j] - rowSumVector[i] - rowSumVector[j];
                S[j][i] = S[i][j];
            }
        }
        return S;
    }

    /**
     *
     * @param D - Distance matrix
     * @param rowSumVector - A vector defined as rowSumVector_i = 1 / (n - 2) * \sum_{j=1}^n D_{i j} for all 1<= i <= n
     * @return A list of pairs of nodes to be joined. The criterion to select a pair of nodes (u, v) is that:
     * S_{u v} \leq S_{u j} and S_{u v} \leq S_{v j} for all u and v different from j, where S is the matrix
     * with the estimators of the sum of the branch lengths
     */
    private List<Pair<Integer, Integer>> findNeighbors (double[][] D, double[] rowSumVector) {
        int n = D.length;
        double[][] S = branchLengthSums(D, rowSumVector);
        double[] rowMin = rowMinimums(S);
        boolean[] taken = new boolean[n];
        double eps = 1e-9;
        BiFunction<Double, Double, Boolean> eq = (x, y) -> x - y < eps;
        List<Pair<Integer, Integer>> neighbors = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (!taken[i] && !taken[j] &&
                        eq.apply(S[i][j], rowMin[i]) &&
                        (S[i][j] < rowMin[j] || eq.apply(S[i][j], rowMin[j]))) {
                    neighbors.add(new Pair<>(i, j));
                    taken[i] = true;
                    taken[j] = true;
                }
            }
        }
        return neighbors;
    }

    /**
     *
     * @param D - Distance matrix
     * @param neighbors - A list of pairs with the nodes to be joined
     * @param indexSet - A flattened version of neighbors in the form of a set. Contains the indices of the neighbors in no particular order
     * @return A new distance matrix D' of size n - m where m = |neighbors| = 1/2*|indexSet| and n * n = |D|.
     * All pair of nodes within the neighbors collection are joined with a node, and these new nodes are added at the end
     * of the matrix as rows and columns in the same order as the neighbors list. Afterwards the distances between new and old nodes
     * is calculated, as well as the distance between new nodes using the distanceBetweenNewNodes method
     */
    private double[][] recalculateDistances (double[][] D,List<Pair<Integer, Integer>> neighbors, Set<Integer> indexSet) {
        int n = D.length;
        int m = neighbors.size();
        double[][] newD = new double[n - m][n - m];

        int x = 0;
        int y = 0;
        for (int i = 0; i < n; i++) {
            if (!indexSet.contains(i)) {
                for (int j = 0; j < n; j++) {
                    if (!indexSet.contains(j)) {
                        newD[x][y] = D[i][j];
                        y++;
                    }
                }
                y = 0;
                x++;
            }
        }

        for (int j = n - 2 * m; j < n - m; j++) {
            x = 0;
            for (int i = 0; i < n; i++) {
                if (!indexSet.contains(i)) {
                	Pair<Integer,Integer> ne = neighbors.get(j - (n - 2 * m));
                    newD[x][j] = NJDistances.distanceBetweenNewAndOldNode(D, ne.first , ne.second, i);
                    newD[j][x] = newD[x][j];
                    x++;
                }
            }
        }

        for (int i = n - 2 * m; i < n - m; i++) {
            for (int j = i + 1; j < n - m; j++) {
            	Pair<Integer,Integer> n1 = neighbors.get(i - (n - 2 * m));
            	Pair<Integer,Integer> n2 = neighbors.get(j - (n - 2 * m));
                newD[i][j] = distanceBetweenNewNodes(D, n1.first, n1.second, n2.first, n2.second);
                newD[j][i] = newD[i][j];
            }
        }

        return newD;
    }

    /**
     * Clusters a given set of sequences characterized by a pairwise distance
     * matrix. Runs the runNeighborJoining function until the resulting list
     * of trees is reduced to only one tree.
     * @param distances - Initial distance matrix
     * @return - A binary tree (dendrogram) that clusters the given sequences.
     */
    @Override
    public Dendrogram buildDendrogram(DistanceMatrix distances) {
    	List<String> names = distances.getIds();
    	List<Dendrogram> subtrees = new ArrayList<>(names.size());
        for (String name : names) subtrees.add(new Dendrogram(name));
        double[][] D = distances.getDistances();
        while (subtrees.size() > 1) {
            double[] rowSumVector = NeighborJoining.neighborJoiningRowSums(D);
            List<Pair<Integer, Integer>> neighbors = findNeighbors(D, rowSumVector);

            List<Dendrogram> newNodes = new ArrayList<>();
            for (int i = 0; i < neighbors.size(); i++) {
                Pair<Integer, Integer> x = neighbors.get(i);
                int u = x.first;
                int v = x.second;
                Dendrogram du = subtrees.get(u);
                Dendrogram dv = subtrees.get(v);
                String newName = du.getLabel()+"!"+dv.getLabel();
                
        		double [] neighborDistances = NJDistances.distanceBetweenNeighbors(D, rowSumVector, u, v);
        		DendrogramEdge e1 = new DendrogramEdge(neighborDistances[0], subtrees.get(u));
    			DendrogramEdge e2 = new DendrogramEdge(neighborDistances[1], subtrees.get(v));
    			Dendrogram newNode = new Dendrogram(newName, List.of(e1,e2));
                newNodes.add(newNode);
            }

            Set<Integer> indices = new HashSet<>();
            for (Pair<Integer, Integer> x : neighbors) {
                indices.add(x.first);
                indices.add(x.second);
            }

            subtrees = deleteFromList(subtrees, indices);
			subtrees.addAll(newNodes);
            D = recalculateDistances(D, neighbors, indices);
        }
        return subtrees.get(0);
    }
}
class Pair <A, B> {
    public final A first;
    public final B second;
    public Pair (A first, B second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public String toString() {
        return "(" + this.first + ", " + this.second + ")";
    }
}
